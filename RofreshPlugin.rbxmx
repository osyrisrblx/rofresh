<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Script" referent="RBX1BC84BE7B0A74FD2A52500BFE9B083C9">
		<Properties>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">RofreshPlugin</string>
			<string name="ScriptGuid">{ED9B9402-A916-40BE-A1E4-2921BC46493A}</string>
			<ProtectedString name="Source"><![CDATA[-- Rofresh Studio Plugin

-- services
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local Selection = game:GetService("Selection")

-- imports
local Project = require(script.Project)

-- config constants
local PORT = 8888
local MAX_REQUESTS_PER_MINUTE = 60
local DEBUG = false
local OUTPUT_PREFIX = "[Rofresh]"

-- static constants
local URL_TEMPLATE = "http://localhost:%d"
local SERVER_URL = string.format(URL_TEMPLATE, PORT)
local HEADERS = { ["client-id"] = string.gsub(HttpService:GenerateGUID(false), "-", "") }

-- error constants
local HTTP_NOT_ENABLED = "Http requests are not enabled. Enable via game settings"
local CURL_PREFIX = "CURL error (curl_easy_perform): "
local CURL_CONNECT_ERROR = CURL_PREFIX .. "Couldn't connect to server (7)"
local CURL_TIMEOUT_ERROR = CURL_PREFIX .. "Timeout was reached (28)"
local CURL_NOTHING_ERROR = CURL_PREFIX .. "Server returned nothing (no headers, no data) (52)"
local CURL_RECEIVE_ERROR = CURL_PREFIX .. "Failure when receiving data from the peer (56)"

-- output helper functions
local function wrapPrinter(printer)
	return function(...)
		printer(OUTPUT_PREFIX, ...)
	end
end
local print = wrapPrinter(print)
local warn = wrapPrinter(warn)

local function debugPrint(...)
	if DEBUG then
		print(...)
	end
end

local pluginId = string.gsub(HttpService:GenerateGUID(false), "-", "")
_G.rofresh = {}
_G.rofresh.pluginId = pluginId
_G.rofresh.debugPrint = debugPrint

-- plugin object creation
do
	local toolbar = plugin:CreateToolbar("Rofresh")

	local syncSelectionButton = toolbar:CreateButton("Sync Selection", "", "")
	syncSelectionButton.ClickableWhenViewportHidden = true
	syncSelectionButton.Click:Connect(function()
		local changes = {}
		for _, selected in pairs(Selection:Get()) do
			debugPrint("syncSelection", selected:GetFullName())
			for _, descendant in pairs(selected:GetDescendants()) do
				if descendant:IsA("LuaSourceContainer") then
					local project = nil
					table.insert(changes, project:getChangeFromScript(descendant))
				end
			end
		end
		--[[
		HttpService:PostAsync(SERVER_URL, HttpService:JSONEncode({
			projectName = "",
			changes = changes,
		}), Enum.HttpContentType.ApplicationJson, false, HEADERS)
		]]
	end)

	-- TODO: remove
	local debugButton = toolbar:CreateButton("Debug", "", "")
	debugButton.ClickableWhenViewportHidden = true
	debugButton.Click:Connect(function()
		DEBUG = not DEBUG
		print("debug", DEBUG)
	end)
end

local httpEnabled = true

local jobId

local function isJobValid(myJobId)
	return myJobId == jobId and _G.rofresh.pluginId == pluginId
end

local n = 0

-- main loop
coroutine.wrap(function()
	while RunService.Heartbeat:Wait() and _G.rofresh.pluginId == pluginId do
		n = n + 1
		local myJobId = {}
		jobId = myJobId

		local success, rawJsonOrError
		local isFinished = false
		coroutine.wrap(function()
			success, rawJsonOrError = pcall(function()
				return HttpService:GetAsync(SERVER_URL, true, HEADERS)
			end)
			isFinished = true
		end)()
		while isJobValid(myJobId) and not isFinished do
			RunService.Heartbeat:Wait()
		end
		if not isJobValid(myJobId) then
			return
		end

		if success then
			if not httpEnabled then
				httpEnabled = true
				print("HttpEnabled, begin sync..")
			end

			if string.len(rawJsonOrError) > 0 then
				local payloadOrError
				success, payloadOrError = pcall(function()
					return HttpService:JSONDecode(rawJsonOrError)
				end)
				if success then
					local payload = payloadOrError
					if not payload.error then
						for i = 1, #payload do
							local projectPayload = payload[i]
							assert(projectPayload.projectName and projectPayload.projectName ~= "")
							assert(projectPayload.changes)

							local project = Project.instances[projectPayload.projectName]
							if not project then
								project = Project.new(projectPayload.projectName, projectPayload.tagOverride)
							end

							if projectPayload.changes or projectPayload.initial then
								project:processChanges(projectPayload.changes, projectPayload.initial)
							end
						end
					else
						-- do throttle
						success = false
						warn("Server Error", payload.error)
					end
				else
					warn("JSON Error", payloadOrError, #rawJsonOrError, rawJsonOrError)
				end
			else
				success = false
			end
		else
			-- HttpService.HttpEnabled prompt
			if rawJsonOrError == HTTP_NOT_ENABLED then
				httpEnabled = false
				Selection:Set({HttpService})
				local prop
				while prop ~= "HttpEnabled" do
					prop = HttpService.Changed:Wait()
				end
				-- bypass throttle
				success = true
			elseif  rawJsonOrError ~= CURL_CONNECT_ERROR
				and rawJsonOrError ~= CURL_TIMEOUT_ERROR
				and rawJsonOrError ~= CURL_NOTHING_ERROR
				and rawJsonOrError ~= CURL_RECEIVE_ERROR then
				-- silence known common server errors
				warn("Connection Error", rawJsonOrError)
			end
		end

		-- dont waste requests
		if not success then
			wait(60/MAX_REQUESTS_PER_MINUTE)
		end
	end
	print("Rofresh ended.")
end)()

local placeId = game.PlaceId
game:GetPropertyChangedSignal("PlaceId"):Connect(function()
	if placeId ~= game.PlaceId then
		_G.rofresh.debugPrint("PlaceId changed, restart request")
		placeId = game.PlaceId
		jobId = nil
	end
end)

print("Rofresh Studio Plugin running..")]]></ProtectedString>
			<BinaryString name="Tags">LlJvZnJlc2hfUm9mcmVzaFBsdWdpbg==</BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBX8656F91240C3487C9B1BDE8CE8CBE64C">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Project</string>
				<string name="ScriptGuid">{7778ADB1-3317-461A-873A-AD802384C56E}</string>
				<ProtectedString name="Source"><![CDATA[-- Project class

-- services
local CollectionService = game:GetService("CollectionService")

-- constants
local TAG_PREFIX = ".Rofresh_"
local CONTAINER_NAME = "init"

-- utility functions
local function existsIn(array, value)
	for i = 1, #array do
		if value == array[i] then
			return true
		end
	end
	return false
end

local function findFirstChildOfNameAndClass(parent, name, classNames)
	if typeof(classNames) == "string" then
		classNames = {classNames}
	end
	for _, child in pairs(parent:GetChildren()) do
		local success, condition = pcall(function()
			return child.Name == name and existsIn(classNames, child.ClassName)
		end)
		if success and condition then
			return child
		end
	end
end

local function findOnPath(path, className)
	local name = table.remove(path)
	local parent = game
	for i = 1, #path do
		parent = parent:FindFirstChild(path[i])
		if not parent then
			return
		end
	end
	return findFirstChildOfNameAndClass(parent, name, className)
end

-- class definition
local Project = {}
Project.instances = {}
Project.__index = Project

function Project.new(id, tagOverride)
	local self = setmetatable({}, Project)
	Project.instances[id] = self
	self.id = id
	self.tag = tagOverride or TAG_PREFIX .. id
	return self
end

local function getPathStr(object)
	local pathStr = object.Name .. "." .. object.ClassName
	local parent = object.Parent
	while parent and parent ~= game do
		pathStr = parent.Name .. "." .. pathStr
		parent = parent.Parent
	end
	return pathStr
end

function Project:unsync(object)
	if CollectionService:HasTag(object, self.tag) then
		local children = object:GetChildren()
		if #children > 0 then
			local folder = Instance.new("Folder")
			CollectionService:AddTag(object, self.tag)
			folder.Name = object.Name
			folder.Parent = object.Parent
			for _, child in pairs(children) do
				child.Parent = folder
			end
			object:Destroy()
		else
			local parent = object.Parent
			object:Destroy()
			if parent and parent:IsA("Folder") and #parent:GetChildren() == 0 then
				self:unsync(parent)
			end
		end
	end
end

function Project:getScriptObject(path, className, isContainer)
	local name = table.remove(path)
	if not name then
		return
	end
	local parent = game
	local pathStart = 1
	local serviceName = path[1]
	if serviceName then
		-- used to create nonexistant services
		pcall(function()
			game = parent:GetService(serviceName)
			pathStart = 2
		end)
	end

	for i = pathStart, #path do
		local object = parent:FindFirstChild(path[i])
		if not object then
			object = Instance.new("Folder", parent)
			CollectionService:AddTag(object, self.tag)
			object.Name = path[i]
		end
		parent = object
	end

	local scriptObject = findFirstChildOfNameAndClass(parent, name, className)
	if not scriptObject then
		if isContainer then
			local folder = findFirstChildOfNameAndClass(parent, name, {"Folder", "Script", "LocalScript", "ModuleScript"})
			if folder then
				scriptObject = Instance.new(className)
				CollectionService:AddTag(scriptObject, self.tag)
				scriptObject.Name = name
				for _, child in pairs(folder:GetChildren()) do
					child.Parent = scriptObject
				end
				folder:Destroy()
				scriptObject.Parent = parent
			else
				scriptObject = Instance.new(className, parent)
				CollectionService:AddTag(scriptObject, self.tag)
				scriptObject.Name = name
			end
		else
			scriptObject = Instance.new(className, parent)
			CollectionService:AddTag(scriptObject, self.tag)
			scriptObject.Name = name
		end
	end

	return scriptObject
end

function Project:processChanges(changes, initial)
	local paths = {}
	for _, change in pairs(changes) do
		local doCreate = change.source ~= nil
		local isContainer = false
		if change.path[#change.path] == CONTAINER_NAME then
			table.remove(change.path)
			isContainer = true
		end
		local pathStr = table.concat(change.path, ".") .. "." .. change.type
		paths[pathStr] = true
		if doCreate then
			_G.rofresh.debugPrint("ADD", pathStr)
			local scriptObject = self:getScriptObject(change.path, change.type, isContainer)
			if scriptObject then
				CollectionService:AddTag(scriptObject, self.tag)
				scriptObject.Source = change.source
			end
		else
			_G.rofresh.debugPrint("REMOVE", pathStr)
			local scriptObject = findOnPath(change.path, change.type)
			if scriptObject then
				self:unsync(scriptObject)
			end
		end
	end
	if initial then
		local syncObjects = CollectionService:GetTagged(self.tag)
		for _, object in pairs(syncObjects) do
			if object:IsA("LuaSourceContainer") then
				local pathStr = getPathStr(object)
				if not paths[pathStr] then
					_G.rofresh.debugPrint("REMOVE", pathStr)
					self:unsync(object)
				end
			end
		end
	end
end

function Project:getPathFromScript(script)
	local path = {}
	local object = script
	while object ~= game do
		table.insert(path, 1, object.Name)
		object = object.Parent
	end
	return path
end

function Project:getChangeFromScript(script)
	return {
		type = script.ClassName,
		source = script.Source,
		path = self:getPathFromScript(script)
	}
end

return Project]]></ProtectedString>
				<BinaryString name="Tags">LlJvZnJlc2hfUm9mcmVzaFBsdWdpbg==</BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>